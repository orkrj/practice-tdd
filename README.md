# 포인트 시스템 동시성 제어 전략

## 문제 정의

포인트 충전/사용 시 여러 스레드가 동시에 같은 사용자의 포인트에 접근할 때 발생하는 **Race Condition** 문제를 해결해야 했습니다.

즉, 동시성 문제로 인해 포인트 충전이 누락되거나, 포인트 사용 시 잔액 계산이 부정확해질 수 있는 상황을 방지하는 것이 목표였습니다.

---

## 동시성 제어 전략 검토

### 1. synchronized 키워드 방식

**배제 이유:**
- **성능 저하**: '모든' 사용자의 포인트 작업이 순차적으로 처리됨 -> 병목 지점
- **확장성 부족**: 사용자 수 증가 시 성능 급격히 저하

### 2. 사용자별 ReentrantLock 방식 ✅

**핵심 구조:**
- **ConcurrentHashMap**: Thread-Safe 한 Lock 저장 및 관리
- **computeIfAbsent**: 원자적으로 Lock 생성
- **userId 별 독립 락**: 각 사용자마다 별도의 ReentrantLock 할당

---

## 유의 포인트

### 1. 메모리 관리
- **tryLock** 기반 비블로킹 정리
- **hasQueuedThreads** 으로 대기 중인 스레드 확인
- 위 두 장치로 사용하지 않는 Lock 안전하게 자동 제거

### 2. 안전성 제고
- **데드락 방지** 메커니즘
- **예외 안전성** 보장
- **finally 블록** 활용한 락 반납

---

## 결론

**사용자별 ReentrantLock** 방식을 통해 동시성 문제를 해결하면서도 성능 최적화와 안정성을 신경 썼습니다.

특히 서로 다른 사용자 간의 락 획득 병렬 처리를 통해 시스템의 처리량 향상을 기대할 수 있었으며, 자동 메모리 관리로 운영 환경에서의 안정성도 보장했습니다.